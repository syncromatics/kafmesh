package generator

import (
	"io"
	"strings"
	"text/template"

	"github.com/syncromatics/kafmesh/internal/models"

	"github.com/iancoleman/strcase"
	"github.com/pkg/errors"
)

var (
	viewSourceTemplate = template.Must(template.New("").Parse(`// Code generated by kafmesh-gen. DO NOT EDIT.

package {{ .Package }}

import (
	"context"
	"os"
	"path/filepath"
	"time"
	"fmt"

	"github.com/burdiyan/kafkautil"
	"github.com/lovoo/goka"
	"github.com/lovoo/goka/storage"
	"github.com/pkg/errors"
	"github.com/syndtr/goleveldb/leveldb/opt"
	"golang.org/x/sync/errgroup"

	"github.com/syncromatics/kafmesh/pkg/runner"

	"{{ .Import }}"
)

type {{ .Name }}_ViewSource_Context interface {
	context.Context
	Update(string, *{{ .MessageType }}) error
}

type {{ .Name }}_ViewSource interface {
	Sync({{ .Name }}_ViewSource_Context) error
}

type contextWrap_{{ .Name }} struct {
	context.Context
	job *runner.ProtoViewSourceJob
}

func (c *contextWrap_{{ .Name }}) Update(key string, msg *{{ .MessageType }}) error {
	return c.job.Update(key, msg)
}

func Register_{{ .Name }}_ViewSource(options runner.ServiceOptions, synchronizer {{ .Name }}_ViewSource, updateInterval time.Duration, syncTimeout time.Duration) (func(context.Context) func() error, error) {
	brokers := options.Brokers
	protoWrapper := options.ProtoWrapper

	codec, err := protoWrapper.Codec("{{ .TopicName }}", &{{ .MessageType }}{})
	if err != nil {
		return nil, errors.Wrap(err, "failed to create codec")
	}

	opts := &opt.Options{
		BlockCacheCapacity: opt.MiB * 1,
		WriteBuffer:        opt.MiB * 1,
	}

	path := filepath.Join("/tmp/storage", "viewSource", "{{ .TopicName }}")

	err = os.MkdirAll(path, os.ModePerm)
	if err != nil {
		return nil, errors.Wrap(err, "failed to create view source db directory")
	}

	builder := storage.BuilderWithOptions(path, opts)
	view, err := goka.NewView(brokers,
		goka.Table("{{ .TopicName }}"),
		codec,
		goka.WithViewStorageBuilder(builder),
		goka.WithViewHasher(kafkautil.MurmurHasher),
	)
	if err != nil {
		return nil, errors.Wrap(err, "failed creating synchronizer view")
	}

	e, err := goka.NewEmitter(brokers,
		goka.Stream("{{ .TopicName }}"),
		codec,
		goka.WithEmitterHasher(kafkautil.MurmurHasher))

	if err != nil {
		return nil, errors.Wrap(err, "failed creating synchronizer emitter")
	}

	emitter := runner.NewEmitter(e)

	return func(outerCtx context.Context) func() error {
		return func() error {
			cancelableCtx, cancel := context.WithCancel(outerCtx)
			defer cancel()
			grp, ctx := errgroup.WithContext(cancelableCtx)

			timer := time.NewTimer(0)
			grp.Go(func() error {
				for {
					select {
					case <-ctx.Done():
						return nil
					case <-timer.C:
						select {
						case <-ctx.Done():
							return nil
						case <-view.WaitRunning():
						}
			
						newContext, cancel := context.WithTimeout(ctx, syncTimeout)
						c := runner.NewProtoViewSourceJob(newContext, view, emitter)
						cw := &contextWrap_{{ .Name }}{newContext, c}
						err := synchronizer.Sync(cw)
						if err != nil {
							cancel()
							fmt.Printf("sync error '%v'", err)
							return err
						}
						err = c.Finish()
						if err != nil {
							cancel()
							fmt.Printf("sync finish error '%v'", err)
							return err
						}
						cancel()
						timer = time.NewTimer(updateInterval)
					}
				}
			})

			grp.Go(emitter.Watch(ctx))
			grp.Go(func() error {
				return view.Run(ctx)
			})

			select {
			case <- ctx.Done():
				err := grp.Wait()
				return err
			}
		}
	}, nil
}
`))
)

type viewSourceOptions struct {
	Package     string
	Import      string
	Name        string
	TopicName   string
	MessageType string
}

func generateViewSource(writer io.Writer, viewSource *viewSourceOptions) error {
	err := viewSourceTemplate.Execute(writer, viewSource)
	if err != nil {
		return errors.Wrap(err, "failed to execute viewSource template")
	}
	return nil
}

func buildViewSourceOptions(pkg string, mod string, modelsPath string, service *models.Service, viewSource models.ViewSource) (*viewSourceOptions, error) {
	options := &viewSourceOptions{
		Package: pkg,
		Name:    viewSource.ToSafeName(),
	}

	var name strings.Builder
	nameFrags := strings.Split(viewSource.Message, ".")
	for _, f := range nameFrags[1:] {
		name.WriteString(strcase.ToCamel(f))
	}

	options.TopicName = viewSource.ToTopicName(service)
	options.Import = viewSource.ToPackage(service)
	options.MessageType = nameFrags[len(nameFrags)-2] + "." + strcase.ToCamel(nameFrags[len(nameFrags)-1])

	return options, nil
}
