package generator_test

import (
	"io/ioutil"
	"path"
	"testing"

	"github.com/stretchr/testify/assert"
)

func validateProcessors(tmpDir string, t *testing.T) {
	s, err := ioutil.ReadFile(path.Join(tmpDir, "internal", "kafmesh", "details", "enricher_processor.km.go"))
	if err != nil {
		t.Fatal(err)
	}

	assert.Equal(t, expectedDetailsProcessor, string(s))
}

var (
	expectedDetailsProcessor = `// Code generated by kafmesh-gen. DO NOT EDIT.

package details

import (
	"context"
	"encoding/json"
	"os"
	"path/filepath"
	"time"

	"github.com/Shopify/sarama"
	"github.com/burdiyan/kafkautil"
	"github.com/lovoo/goka"
	"github.com/lovoo/goka/storage"
	"github.com/pkg/errors"
	"github.com/syndtr/goleveldb/leveldb/opt"

	"github.com/syncromatics/kafmesh/pkg/runner"

	m0 "test/internal/kafmesh/models/testMesh/testId"
	m1 "test/internal/kafmesh/models/testMesh/testSerial"
)

type Enricher_ProcessorContext interface {
	Key() string
	Timestamp() time.Time
	Lookup_TestSerialDetails(key string) *m1.Details
	Join_TestSerialDetails() *m1.Details
	Output_TestSerialDetailsEnriched(key string, message *m1.DetailsEnriched)
	SaveState(state *m1.DetailsState)
	State() *m1.DetailsState
}

type Enricher_Processor interface {
	HandleTestIDTest(ctx Enricher_ProcessorContext, message *m0.Test) error
	HandleTestIDTest2(ctx Enricher_ProcessorContext, message *m0.Test2) error
}

type Enricher_ProcessorContext_Impl struct {
	ctx              goka.Context
	processorContext *runner.ProcessorContext
}

func new_Enricher_ProcessorContext_Impl(ctx goka.Context, pc *runner.ProcessorContext) *Enricher_ProcessorContext_Impl {
	return &Enricher_ProcessorContext_Impl{ctx, pc}
}

func (c *Enricher_ProcessorContext_Impl) Key() string {
	return c.ctx.Key()
}

func (c *Enricher_ProcessorContext_Impl) Timestamp() time.Time {
	return c.ctx.Timestamp()
}

func (c *Enricher_ProcessorContext_Impl) Lookup_TestSerialDetails(key string) *m1.Details {
	v := c.ctx.Lookup("testMesh.testSerial.details", key)
	if v == nil {
		c.processorContext.Lookup("testMesh.testSerial.details", "testSerial.details", key, "")
		return nil
	}

	m := v.(*m1.Details)
	value, _ := json.Marshal(m)
	c.processorContext.Lookup("testMesh.testSerial.details", "testSerial.details", key, string(value))

	return m
}

func (c *Enricher_ProcessorContext_Impl) Join_TestSerialDetails() *m1.Details {
	v := c.ctx.Join("testMesh.testSerial.details")
	if v == nil {
		c.processorContext.Join("testMesh.testSerial.details", "testSerial.details", "")
		return nil
	}

	m := v.(*m1.Details)
	value, _ := json.Marshal(m)
	c.processorContext.Join("testMesh.testSerial.details", "testSerial.details", string(value))

	return m
}

func (c *Enricher_ProcessorContext_Impl) Output_TestSerialDetailsEnriched(key string, message *m1.DetailsEnriched) {
	value, _ := json.Marshal(message)
	c.processorContext.Output("testMesh.testSerial.detailsEnriched", "testSerial.detailsEnriched", key, string(value))
	c.ctx.Emit("testMesh.testSerial.detailsEnriched", key, message)
}

func (c *Enricher_ProcessorContext_Impl) SaveState(state *m1.DetailsState) {
	value, _ := json.Marshal(state)
	c.processorContext.SetState("testMesh.details.enricher-table", "testSerial.detailsState", string(value))

	c.ctx.SetValue(state)
}

func (c *Enricher_ProcessorContext_Impl) State() *m1.DetailsState {
	v := c.ctx.Value()
	var m *m1.DetailsState
	if v == nil {
		m = &m1.DetailsState{}
	} else {
		m = v.(*m1.DetailsState)
	}

	value, _ := json.Marshal(m)
	c.processorContext.GetState("testMesh.details.enricher-table", "testSerial.detailsState", string(value))

	return m
}

func Register_Enricher_Processor(service *runner.Service, impl Enricher_Processor) (func(context.Context) func() error, error) {
	options := service.Options()
	brokers := options.Brokers
	protoWrapper := options.ProtoWrapper

	config := sarama.NewConfig()
	config.Consumer.Offsets.Initial = sarama.OffsetOldest

	opts := &opt.Options{
		BlockCacheCapacity: opt.MiB * 1,
		WriteBuffer:        opt.MiB * 1,
	}

	path := filepath.Join("/tmp/storage", "processor", "testMesh.details.enricher")

	err := os.MkdirAll(path, os.ModePerm)
	if err != nil {
		return nil, errors.Wrap(err, "failed to create processor db directory")
	}

	builder := storage.BuilderWithOptions(path, opts)


	c0, err := protoWrapper.Codec("testMesh.testId.test", &m0.Test{})
	if err != nil {
		return nil, errors.Wrap(err, "failed to create codec")
	}

	c1, err := protoWrapper.Codec("testMesh.testId.test2", &m0.Test2{})
	if err != nil {
		return nil, errors.Wrap(err, "failed to create codec")
	}

	c2, err := protoWrapper.Codec("testMesh.testSerial.details", &m1.Details{})
	if err != nil {
		return nil, errors.Wrap(err, "failed to create codec")
	}

	c3, err := protoWrapper.Codec("testMesh.testSerial.detailsEnriched", &m1.DetailsEnriched{})
	if err != nil {
		return nil, errors.Wrap(err, "failed to create codec")
	}

	c4, err := protoWrapper.Codec("testMesh.details.enricher-table", &m1.DetailsState{})
	if err != nil {
		return nil, errors.Wrap(err, "failed to create codec")
	}

	edges := []goka.Edge{
		goka.Input(goka.Stream("testMesh.testId.test"), c0, func(ctx goka.Context, m interface{}) {
			msg := m.(*m0.Test)

			pc := service.ProcessorContext(ctx.Context(), "details", "enricher", ctx.Key())
			defer pc.Finish()

			v, err := json.Marshal(msg)
			if err != nil {
				ctx.Fail(err)
			}
			pc.Input("testMesh.testId.test", "testId.test", string(v))

			w := new_Enricher_ProcessorContext_Impl(ctx, pc)
			err = impl.HandleTestIDTest(w, msg)
			if err != nil {
				ctx.Fail(err)
			}
		}),
		goka.Input(goka.Stream("testMesh.testId.test2"), c1, func(ctx goka.Context, m interface{}) {
			msg := m.(*m0.Test2)

			pc := service.ProcessorContext(ctx.Context(), "details", "enricher", ctx.Key())
			defer pc.Finish()

			v, err := json.Marshal(msg)
			if err != nil {
				ctx.Fail(err)
			}
			pc.Input("testMesh.testId.test2", "testId.test2", string(v))

			w := new_Enricher_ProcessorContext_Impl(ctx, pc)
			err = impl.HandleTestIDTest2(w, msg)
			if err != nil {
				ctx.Fail(err)
			}
		}),
		goka.Lookup(goka.Table("testMesh.testSerial.details"), c2),
		goka.Join(goka.Table("testMesh.testSerial.details"), c2),
		goka.Output(goka.Stream("testMesh.testSerial.detailsEnriched"), c3),
		goka.Persist(c4),
	}
	group := goka.DefineGroup(goka.Group("testMesh.details.enricher"), edges...)

	processor, err := goka.NewProcessor(brokers,
		group,
		goka.WithConsumerGroupBuilder(goka.ConsumerGroupBuilderWithConfig(config)),
		goka.WithStorageBuilder(builder),
		goka.WithHasher(kafkautil.MurmurHasher))
	if err != nil {
		return nil, errors.Wrap(err, "failed to create goka processor")
	}

	return func(ctx context.Context) func() error {
		return func() error {
			err := processor.Run(ctx)
			if err != nil {
				return errors.Wrap(err, "failed to run goka processor")
			}

			return nil
		}
	}, nil
}
`
)
