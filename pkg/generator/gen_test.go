package generator_test

import (
	"io/ioutil"
	"os"
	"path"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/syncromatics/kafmesh/pkg/generator"
	"github.com/syncromatics/kafmesh/pkg/models"
)

func Test_Generator(t *testing.T) {
	tmpDir, err := ioutil.TempDir("", "Test_Generator")
	if err != nil {
		t.Fatal(err)
	}
	//tmpDir = path.Join("/tmp", "genTest")

	protoDir := path.Join(tmpDir, "protos")
	err = os.MkdirAll(protoDir, os.ModePerm)
	if err != nil {
		t.Fatal(err)
	}

	package1 := path.Join(protoDir, "testMesh", "testId")
	err = os.MkdirAll(package1, os.ModePerm)
	if err != nil {
		t.Fatal(err)
	}

	ioutil.WriteFile(path.Join(package1, "test.proto"), []byte(`syntax ="proto3";
package testMesh.testId;

message Test {
	string name = 1;
}`), os.ModePerm)

	ioutil.WriteFile(path.Join(package1, "test2.proto"), []byte(`syntax ="proto3";
package testMesh.testId;

message Test2 {
	string serial = 1;
}`), os.ModePerm)

	package2 := path.Join(protoDir, "testMesh", "testSerial")
	err = os.MkdirAll(package2, os.ModePerm)
	if err != nil {
		t.Fatal(err)
	}

	ioutil.WriteFile(path.Join(package2, "details.proto"), []byte(`syntax ="proto3";
package testMesh.testSerial;

message Details {
	string name = 1;
}`), os.ModePerm)

	ioutil.WriteFile(path.Join(package2, "detailsState.proto"), []byte(`syntax ="proto3";
package testMesh.testSerial;

message DetailsState {
	string name = 1;
}`), os.ModePerm)

	ioutil.WriteFile(path.Join(package2, "detailsEnriched.proto"), []byte(`syntax ="proto3";
package testMesh.testSerial;

message DetailsEnriched {
	string name = 1;
}`), os.ModePerm)

	options := generator.Options{
		Service: &models.Service{
			Output: models.OutputSettings{
				Path:    "internal/kafmesh",
				Package: "kafmesh",
				Module:  "test",
			},
			Messages: models.MessageDefinitions{
				Protobuf: []string{
					"./protos",
				},
			},
		},
		RootPath:        tmpDir,
		DefinitionsPath: tmpDir,
		Components: []*models.Component{
			&models.Component{
				Name: "details",
				Processors: []models.Processor{
					models.Processor{
						GroupName: "testMesh.testId.test2",
						Inputs: []models.Input{
							models.Input{
								TopicDefinition: models.TopicDefinition{
									Message: "testMesh.testId.test",
								},
							},
							models.Input{
								TopicDefinition: models.TopicDefinition{
									Message: "testMesh.testId.test2",
								},
							},
						},
						Lookups: []models.Lookup{
							models.Lookup{
								TopicDefinition: models.TopicDefinition{
									Message: "testMesh.testSerial.details",
								},
							},
						},
						Joins: []models.Join{
							models.Join{
								TopicDefinition: models.TopicDefinition{
									Message: "testMesh.testSerial.details",
								},
							},
						},
						Outputs: []models.Output{
							models.Output{
								TopicDefinition: models.TopicDefinition{
									Message: "testMesh.testSerial.detailsEnriched",
								},
							},
						},
						Persistence: &models.Persistence{
							TopicDefinition: models.TopicDefinition{
								Message: "testMesh.testSerial.detailsState",
							},
						},
					},
				},
				Emitters: []models.Emitter{
					models.Emitter{
						TopicDefinition: models.TopicDefinition{
							Message: "testMesh.testSerial.details",
						},
					},
				},
				Sinks: []models.Sink{
					models.Sink{
						Name: "Enriched Data Postgres",
						TopicDefinition: models.TopicDefinition{
							Message: "testMesh.testSerial.detailsEnriched",
						},
					},
				},
				Views: []models.View{
					models.View{
						TopicDefinition: models.TopicDefinition{
							Message: "testMesh.testSerial.detailsEnriched",
						},
					},
				},
				Synchronizers: []models.Synchronizer{
					models.Synchronizer{
						TopicDefinition: models.TopicDefinition{
							Message: "testMesh.testId.test",
						},
					},
				},
			},
		},
	}

	err = generator.Generate(options)
	if err != nil {
		t.Fatal(err)
	}

	validateProcessors(tmpDir, t)
	validateEmitter(tmpDir, t)
	validateSink(tmpDir, t)
	validateView(tmpDir, t)
	validateSynchronizer(tmpDir, t)

	s, err := ioutil.ReadFile(path.Join(tmpDir, "internal", "kafmesh", "service.km.go"))
	if err != nil {
		t.Fatal(err)
	}

	assert.Equal(t, expectedService, string(s))
}

var (
	expectedService = `// Code generated by kafmesh-gen. DO NOT EDIT.
package kafmesh

import (
	"github.com/syncromatics/kafmesh/pkg/runner"
	"github.com/pkg/errors"
	"test/internal/kafmesh/details"
)
func Register_TestMeshTestIdTest2Processor(service *runner.Service, processor details.TestMeshTestIdTest2Processor) error {
	r, err := details.Register_TestMeshTestIdTest2Processor(service.Options(), processor)
	if err != nil {
		return errors.Wrap(err, "failed to register processor")
	}

	err = service.RegisterRunner(r)
	if err != nil {
		return errors.Wrap(err, "failed to register runner with service")
	}

	return nil
}
`
)
