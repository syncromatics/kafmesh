package generator_test

import (
	"io/ioutil"
	"path"
	"testing"

	"github.com/stretchr/testify/assert"
)

func validateEmitter(tmpDir string, t *testing.T) {
	s, err := ioutil.ReadFile(path.Join(tmpDir, "internal", "kafmesh", "details", "testMesh_testSerial_details_emitter.km.go"))
	if err != nil {
		t.Fatal(err)
	}

	assert.Equal(t, expectedEmitter, string(s))
}

var (
	expectedEmitter = `// Code generated by kafmesh-gen. DO NOT EDIT.

package details

import (
	"context"

	"github.com/burdiyan/kafkautil"
	"github.com/lovoo/goka"
	"github.com/pkg/errors"

	"github.com/syncromatics/kafmesh/pkg/runner"

	testSerial "test/internal/kafmesh/models/testMesh/testSerial"
)

type TestSerial_Details_Emitter struct {
	emitter *runner.Emitter
}

type TestSerial_Details_Emitter_Message struct {
	Key string
	Value *testSerial.Details
}

func New_TestSerial_Details_Emitter(options runner.ServiceOptions) (*TestSerial_Details_Emitter, error) {
	brokers := options.Brokers
	protoWrapper := options.ProtoWrapper

	codec, err := protoWrapper.Codec("testMesh.testSerial.details", &testSerial.Details{})
	if err != nil {
		return nil, errors.Wrap(err, "failed to create codec")
	}

	emitter, err := goka.NewEmitter(brokers,
		goka.Stream("testMesh.testSerial.details"),
		codec,
		goka.WithEmitterHasher(kafkautil.MurmurHasher))

	if err != nil {
		return nil, errors.Wrap(err, "failed creating emitter")
	}

	return &TestSerial_Details_Emitter{
		emitter: runner.NewEmitter(emitter),
	}, nil
}

func (e *TestSerial_Details_Emitter) Watch(ctx context.Context) func() error {
	return e.emitter.Watch(ctx)
}

func (e *TestSerial_Details_Emitter) Emit(message *TestSerial_Details_Emitter_Message) error {
	return e.Emit(message.Key, message.Value)
}

func (e *TestSerial_Details_Emitter) EmitBulk(ctx context.Context, messages []*TestSerial_Details_Emitter_Message) error {
	return e.emitter.EmitBulk(ctx, messages)
}
`
)
