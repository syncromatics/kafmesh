package generator

import (
	"fmt"
	"io"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"
	"github.com/pkg/errors"
	"github.com/syncromatics/kafmesh/pkg/models"
)

var (
	viewTemplate = template.Must(template.New("").Parse(`// Code generated by kafmesh-gen. DO NOT EDIT.

package {{ .Package }}

import (
	"context"

	"github.com/burdiyan/kafkautil"
	"github.com/lovoo/goka"
	"github.com/lovoo/goka/kafka"
	"github.com/lovoo/goka/storage"
	"github.com/pkg/errors"
	"github.com/syndtr/goleveldb/leveldb/opt"

	"github.com/syncromatics/kafmesh/pkg/runner"
	"{{ .Import }}"
)

type {{ .Name }}_View struct {
	view *goka.View
}

func New_{{ .Name }}_View(options runner.ServiceOptions) (*{{ .Name }}_View, error) {
	brokers := options.Brokers
	protoWrapper := options.ProtoWrapper

	codec, err := protoWrapper.Codec("{{ .TopicName }}", &{{ .MessageType }}{})
	if err != nil {
		return nil, errors.Wrap(err, "failed to create codec")
	}

	var builder storage.Builder
	if g.settings.StorageInMemory {
		builder = storage.MemoryBuilder()
	} else {
		opts := &opt.Options{
			BlockCacheCapacity: opt.MiB * 1,
			WriteBuffer:        opt.MiB * 1,
		}

		path := filepath.Join("/tmp/storage", "view", "{{ .TopicName }}")

		err := os.MkdirAll(path, os.ModePerm)
		if err != nil {
			return nil, errors.Wrap(err, "failed to create view db directory")
		}

		builder = storage.BuilderWithOptions(path, opts)
	}

	view, err := goka.NewView(g.settings.Brokers,
		goka.Table("{{ .TopicName }}"),
		codec,
		goka.WithViewStorageBuilder(builder),
		goka.WithViewHasher(kafkautil.MurmurHasher),
	)

	if err != nil {
		return nil, errors.Wrap(err, "failed creating view")
	}

	return &{{ .Name }}_View{
		view: view,
	}, nil
}

func (v *{{ .Name }}_View) Watch(ctx context.Context) func() error {
	return v.view.Run(ctx)
}

func (v *{{ .Name }}_View) Keys() []string {
	return v.Keys()
}

func (v *{{ .Name }}_View) Get(key string) (*{{ .MessageType }}, error) {
	m, err := v.view.Get(key)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get value from view")
	}

	msg, ok := m.(*{{ .MessageType }})
	if !ok {
		return nil, errors.Errorf("expecting message of type '*{{ .MessageType }}' got type '%t'", m)
	}

	return msg, nil
}
`))
)

type viewOptions struct {
	Package     string
	Import      string
	Name        string
	TopicName   string
	MessageType string
}

func generateView(writer io.Writer, view *viewOptions) error {
	err := viewTemplate.Execute(writer, view)
	if err != nil {
		return errors.Wrap(err, "failed to execute view template")
	}
	return nil
}

func buildViewOptions(pkg string, mod string, modelsPath string, view models.View) (*viewOptions, error) {
	options := &viewOptions{
		Package: pkg,
	}

	var name strings.Builder
	nameFrags := strings.Split(view.Message, ".")
	for _, f := range nameFrags[1:] {
		name.WriteString(strcase.ToCamel(f))
		name.WriteString("_")
	}

	topic := view.Message
	if view.TopicDefinition.Topic != nil {
		topic = *view.TopicDefinition.Topic
	}

	options.TopicName = topic
	options.Name = strings.TrimRight(name.String(), "_")

	var mPkg strings.Builder
	for _, p := range nameFrags[:len(nameFrags)-1] {
		mPkg.WriteString("/")
		mPkg.WriteString(p)
	}

	imp := strings.TrimPrefix(mPkg.String(), "/")
	options.Import = fmt.Sprintf("%s%s/%s", mod, modelsPath, imp)

	options.MessageType = nameFrags[len(nameFrags)-2] + "." + strcase.ToCamel(nameFrags[len(nameFrags)-1])

	return options, nil
}
